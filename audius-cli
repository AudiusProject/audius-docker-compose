#!/usr/bin/env python3

import json
import os
import pathlib
import subprocess
import sys
import urllib.error
import urllib.request

import click
import crontab
import dotenv
import psutil

RECOMMENDED_CPU_COUNT = 8
RECOMMENDED_MEMORY = 16

SERVICE_PORTS = {
    "discovery-provider": "5000",
    "creator-node": "4000",
    "identity-server": "7000",
}

service_type = click.Choice(["creator-node", "discovery-provider"])
environment = click.Choice(["prod", "stage"])
container_type = click.Choice(["backend", "cache", "db"])


def update_base_env(ctx, environment):
    """
    Sets the base env in .env for each service and
    returns the name of the base env file to use.
    """
    for service in ["creator-node", "discovery-provider"]:
        env_file = ctx.obj["manifests_path"] / service / ".env"
        dotenv.set_key(env_file, "ENV", environment)
    return f"{environment}.env"


@click.group()
@click.pass_context
def cli(ctx):
    """A tool for managing audius services"""
    ctx.ensure_object(dict)
    ctx.obj["manifests_path"] = pathlib.Path(
        os.getenv("MANIFESTS_PATH", os.path.dirname(os.path.realpath(__file__)))
    )


@cli.command()
@click.argument("service", type=service_type)
@click.option("--environment", type=environment, default="prod")
@click.pass_context
def check_config(ctx, service, environment):
    """Check the config for a service"""
    env = ctx.obj["manifests_path"] / service / update_base_env(ctx, environment)
    override_env = ctx.obj["manifests_path"] / service / "override.env"

    env_data = dotenv.dotenv_values(env)
    override_env_data = dotenv.dotenv_values(override_env)

    unset = False
    for key, value in env_data.items():
        if override_env_data.get(key, value) == "":
            unset = True
            click.secho(f"{key} is not set", fg="red")

    if unset:
        sys.exit(1)
    else:
        click.secho("All keys are set", fg="green")


@cli.command()
@click.argument("service", type=service_type)
@click.pass_context
def health_check(ctx, service):
    """Check the health of a service"""
    proc = subprocess.run(
        [
            "docker",
            "compose",
            "--project-directory",
            ctx.obj["manifests_path"] / service,
            "ps",
            "-q",
            "backend",
        ],
        capture_output=True,
    )

    if proc.returncode:
        click.secho("Service is not running", fg="yellow")
        sys.exit(1)

    try:
        response = json.load(
            urllib.request.urlopen(
                f"http://localhost:{SERVICE_PORTS[service]}/health_check"
            )
        )

        click.secho("Response:", bold=True)
        click.echo(json.dumps(response, indent=2, sort_keys=True))

        partial = False
        if service == "creator-node":
            healthy = response["data"]["healthy"]
        elif service == "discovery-provider":
            healthy = "block_difference" in response["data"]
            block_diff = response["data"]["block_difference"]
            max_block_diff = response["data"]["maximum_healthy_block_difference"]
            partial = block_diff > max_block_diff
            if block_diff > max_block_diff:
                click.secho(
                    f"Block difference ({block_diff}) is greater than maximum healthy block difference ({max_block_diff})",
                    fg="yellow",
                )
        elif service == "identity":
            healthy = response["healthy"]

        if healthy and partial:
            click.secho("Service is partially healthy", fg="yellow")
            sys.exit(2)
        elif healthy:
            click.secho("Service is healthy", fg="green")
            sys.exit(0)
        else:
            click.secho("Service is not healthy", fg="red")
            sys.exit(1)
    except (ConnectionError, urllib.error.HTTPError, json.JSONDecodeError):
        click.secho("Service is not healthy", fg="red")
        sys.exit(1)


@cli.command()
@click.argument("service", type=service_type)
@click.option("--seed", is_flag=True)
@click.option("--environment", type=environment, default="prod")
@click.pass_context
def launch(ctx, service, seed, environment):
    """Launch the service"""
    update_base_env(ctx, environment)

    try:
        ctx.invoke(check_config, service=service)
    except SystemExit:
        pass

    total_memory = psutil.virtual_memory().total // (1024 ** 3)
    cpu_count = psutil.cpu_count()

    click.echo(f"CPUs:\t{cpu_count}\t(recommended: {RECOMMENDED_CPU_COUNT})")
    click.echo(f"Memory:\t{total_memory}GB\t(recommended: {RECOMMENDED_MEMORY}GB)")

    if cpu_count < RECOMMENDED_CPU_COUNT or total_memory < RECOMMENDED_MEMORY:
        click.secho("System does not meet recommended requirements", fg="red")
    else:
        click.secho("System meets recommended requirements", fg="green")

    click.confirm(click.style("Do you want to continue?", bold=True), abort=True)

    if seed and service == "discovery-provider":
        # make sure backend is not running
        subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / service,
                "down",
                "backend",
            ],
        )

        click.secho("Seeding the discovery provider", fg="yellow")
        subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / "discovery-provider",
                "run",
                "seed",
            ],
        )

    subprocess.run(
        [
            "docker",
            "compose",
            "--project-directory",
            ctx.obj["manifests_path"] / service,
            "up",
            "-d",
        ],
    )


@cli.command()
@click.argument("service", type=service_type)
@click.argument("containers", type=container_type, nargs=-1)
@click.pass_context
def logs(ctx, service, containers):
    """Get logs for a service/container"""
    subprocess.run(
        [
            "docker",
            "compose",
            "--project-directory",
            ctx.obj["manifests_path"] / service,
            "logs",
            "-f",
            *containers,
        ],
    )


@cli.command()
@click.argument("service", type=service_type, required=False)
@click.argument("containers", type=container_type, nargs=-1)
@click.pass_context
def restart(ctx, service, containers):
    """Restart a service/container"""
    services = [service]
    if service is None:
        services = ["discovery-provider", "creator-node"]

    filtered = []
    for service in services:
        proc = subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / service,
                "ps",
                "-q",
                "backend",
            ],
            capture_output=True,
        )

        if proc.stdout:
            filtered.append(service)

    for service in services:
        subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / service,
                "up",
                "--build",
                "--force-recreate",
                "-d",
                *containers,
            ],
        )


@cli.command()
@click.argument("service", type=service_type)
@click.argument("key", required=False)
@click.argument("value", required=False)
@click.option("--unset", is_flag=True)
@click.option("--required", is_flag=True)
@click.option("--environment", type=environment, default="prod")
@click.pass_context
def set_config(ctx, service, unset, required, key, value, environment):
    """Set a config value"""
    if required and (key or value):
        click.secho("--required cannot be used when key or value is set", fg="red")
        sys.exit(1)

    env = ctx.obj["manifests_path"] / service / update_base_env(ctx, environment)
    env_data = dotenv.dotenv_values(env)

    override_env = ctx.obj["manifests_path"] / service / "override.env"
    override_env_data = dotenv.dotenv_values(override_env)

    if required:
        for key, value in env_data.items():
            if not unset and value == "":
                dotenv.set_key(
                    override_env,
                    key,
                    click.prompt(
                        click.style(key, bold=True),
                        override_env_data.get(key, env_data.get(key)),
                    ),
                )
            if unset and value == "":
                dotenv.unset_key(override_env, key)
    else:
        if key is None:
            key = click.prompt(click.style("Key", bold=True))
        if not unset and value is None:
            value = click.prompt(click.style("Value", bold=True))

        if unset:
            dotenv.unset_key(override_env, key)
        else:
            dotenv.set_key(override_env, key, value)


@cli.command()
@click.argument("tag", required=False)
@click.option("--unset", is_flag=True)
@click.pass_context
def set_tag(ctx, unset, tag):
    """Set a config value"""
    if not unset and tag is None:
        tag = click.prompt(click.style("Tag", bold=True))

    for service in ["creator-node", "discovery-provider"]:
        env_file = ctx.obj["manifests_path"] / service / ".env"

        if unset:
            dotenv.unset_key(env_file, "TAG")
        else:
            dotenv.set_key(env_file, "TAG", tag)


@cli.command()
@click.argument("branch", required=False)
@click.pass_context
def pull(ctx, branch):
    """Pull latest updates from remote"""
    try:
        subprocess.run(["git", "fetch"], check=True, cwd=ctx.obj["manifests_path"])
        if branch:
            subprocess.run(
                ["git", "checkout", branch], check=True, cwd=ctx.obj["manifests_path"]
            )
        subprocess.run(["git", "pull"], check=True, cwd=ctx.obj["manifests_path"])
    except subprocess.CalledProcessError:
        click.secho("Could not pull", fg="red")
        sys.exit(1)


@cli.command()
@click.argument("branch", required=False)
@click.pass_context
def upgrade(ctx, branch):
    """Pull and restarts all running services"""
    ctx.forward(pull)
    ctx.invoke(restart)


@cli.command()
@click.argument("cron-expression", default="0 */6 * * *")
@click.option("--remove", is_flag=True)
@click.pass_context
def auto_upgrade(ctx, remove, cron_expression):
    """Setup auto upgrade with a cron job"""
    with crontab.CronTab(user=True) as cron:
        for job in cron.find_comment("audius-cli auto-upgrade"):
            cron.remove(job)

        if not remove:
            log_file = ctx.obj["manifests_path"] / "auto-upgrade.log"
            job = cron.new(
                f"date >> {log_file}; /usr/local/bin/audius-cli upgrade >> {log_file} 2>&1",
                "audius-cli auto-upgrade",
            )

            job.setall(cron_expression)


if __name__ == "__main__":
    cli(obj={})
