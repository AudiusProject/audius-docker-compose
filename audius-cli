#!/usr/bin/env python3

import json
import os
import pathlib
import subprocess
import sys
import urllib.error
import urllib.request

import click
import crontab
import dotenv
import psutil

RECOMMENDED_CPU_COUNT = 8
RECOMMENDED_MEMORY = 16

SERVICE_PORTS = {
    "discovery-provider": "5000",
    "creator-node": "4000",
    "identity-server": "7000",
}

service_type = click.Choice(["creator-node", "discovery-provider"])
container_type = click.Choice(["backend", "cache", "db"])


@click.group()
@click.pass_context
def cli(ctx):
    """A tool for managing audius services"""
    ctx.ensure_object(dict)
    ctx.obj["manifests_path"] = pathlib.Path(
        os.getenv("MANIFESTS_PATH", os.path.dirname(os.path.realpath(__file__)))
    )


@cli.command()
@click.argument("service", type=service_type)
@click.pass_context
def check_config(ctx, service):
    """Check the config for a service"""
    env = ctx.obj["manifests_path"] / service / "env"
    override_env = ctx.obj["manifests_path"] / service / "override.env"

    env_data = dotenv.dotenv_values(env)
    override_env_data = dotenv.dotenv_values(override_env)

    unset = False
    for key, value in env_data.items():
        if override_env_data.get(key, value) == "":
            unset = True
            click.secho(f"{key} is not set", fg="red")

    if unset:
        sys.exit(1)


@cli.command()
@click.argument("service", type=service_type)
@click.pass_context
def health_check(ctx, service):
    """Check the health of a service"""
    proc = subprocess.run(
        [
            "docker",
            "compose",
            "--project-directory",
            ctx.obj["manifests_path"] / service,
            "ps",
            "-q",
            "backend",
        ],
        capture_output=True,
    )

    if proc.returncode:
        click.secho("Service is not running", fg="yellow")
        sys.exit(1)

    try:
        response = json.load(
            urllib.request.urlopen(
                f"http://localhost:{SERVICE_PORTS[service]}/health_check"
            )
        )

        if service == "creator-node":
            healthy = response["data"]["healthy"]
        elif service == "discovery-provider":
            healthy = (
                response["data"]["block_difference"]
                < response["data"]["maximum_healthy_block_difference"]
            )
        elif service == "identity":
            healthy = response["healthy"]

        if healthy:
            click.secho("Service is healthy", fg="green")
            sys.exit(0)
        else:
            click.secho("Service is not healthy", fg="red")
            sys.exit(1)
    except (ConnectionError, urllib.error.HTTPError, json.JSONDecodeError):
        click.secho("Service is not healthy", fg="red")
        sys.exit(1)


@cli.command()
@click.option("--seed-job", is_flag=True)
@click.argument("service", type=service_type)
@click.pass_context
def launch(ctx, seed_job, service):
    """Launch the service"""
    try:
        ctx.invoke(check_config, service=service)
    except SystemExit:
        pass

    total_memory = psutil.virtual_memory().total // (1024 ** 3)
    cpu_count = psutil.cpu_count()

    click.echo(f"CPUs:\t{cpu_count}\t(recommended: {RECOMMENDED_CPU_COUNT})")
    click.echo(f"Memory:\t{total_memory}GB\t(recommended: {RECOMMENDED_MEMORY}GB)")

    if cpu_count < RECOMMENDED_CPU_COUNT or total_memory < RECOMMENDED_MEMORY:
        click.secho("System does not meet recommended requirements", fg="red")
    else:
        click.secho("System meets recommended requirements", fg="green")

    click.confirm(click.style("Do you want to continue?", bold=True), abort=True)

    if seed_job and service == "discovery-provider":
        # make sure backend is not running
        subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / service,
                "down",
                "backend",
            ],
        )

        click.secho("Seeding the discovery provider", fg="yellow")
        subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / "discovery-provider",
                "run",
                "seed-job",
            ],
        )

    subprocess.run(
        [
            "docker",
            "compose",
            "--project-directory",
            ctx.obj["manifests_path"] / service,
            "up",
            "-d",
        ],
    )


@cli.command()
@click.argument("service", type=service_type)
@click.argument("containers", type=container_type, nargs=-1)
@click.pass_context
def logs(ctx, service, containers):
    """Get logs for a service/container"""
    subprocess.run(
        [
            "docker",
            "compose",
            "--project-directory",
            ctx.obj["manifests_path"] / service,
            "logs",
            "-f",
            *containers,
        ],
    )


@cli.command()
@click.argument("service", type=service_type, required=False)
@click.argument("containers", type=container_type, nargs=-1)
@click.pass_context
def restart(ctx, service, containers):
    """Restart a service/container"""
    services = [service]
    if service is None:
        proc = subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / service,
                "ps",
                "-q",
                "backend",
            ],
            capture_output=True,
        )

        services = proc.stdout.decode("utf-8").splitlines()

    for service in services:
        subprocess.run(
            [
                "docker",
                "compose",
                "--project-directory",
                ctx.obj["manifests_path"] / service,
                "up",
                *containers,
            ],
        )


@cli.command()
@click.option("--unset", is_flag=True)
@click.argument("service", type=service_type)
@click.argument("key", required=False)
@click.argument("value", required=False)
@click.pass_context
def set_config(ctx, service, unset, key, value):
    """Set a config value"""
    if key is None:
        key = click.prompt(click.style("Key", bold=True))
    if not unset and value is None:
        value = click.prompt(click.style("Value", bold=True))

    env_file = ctx.obj["manifests_path"] / service / "override.env"

    if unset:
        dotenv.unset_key(env_file, key)
    else:
        dotenv.set_key(env_file, key, value)


@cli.command()
@click.option("--unset", is_flag=True)
@click.argument("tag", required=False)
@click.pass_context
def set_tag(ctx, service, unset, tag):
    """Set a config value"""
    if not unset and tag is None:
        tag = click.prompt(click.style("Tag", bold=True))

    env_file = ctx.obj["manifests_path"] / service / ".env"

    if unset:
        dotenv.unset_key(env_file, "TAG")
    else:
        dotenv.set_key(env_file, "TAG", tag)


@cli.command()
@click.argument("branch", required=False)
@click.pass_context
def pull(ctx, branch):
    """Pull latest updates from remote"""
    try:
        subprocess.run(["git", "fetch"], check=True, cwd=ctx.obj["manifests_path"])
        if branch:
            subprocess.run(
                ["git", "checkout", branch], check=True, cwd=ctx.obj["manifests_path"]
            )
        subprocess.run(["git", "pull"], check=True, cwd=ctx.obj["manifests_path"])
    except subprocess.CalledProcessError:
        click.secho("Could not pull", fg="red")
        sys.exit(1)


@cli.command()
@click.argument("branch", required=False)
@click.pass_context
def upgrade(ctx, branch):
    """Pull and restarts all running services"""
    ctx.forward(pull)
    ctx.invoke(restart)


@cli.command()
@click.option("--remove", is_flag=True)
@click.argument("cron-expression", default="0 */6 * * *")
@click.pass_context
def auto_upgrade(ctx, remove, cron_expression):
    """Setup auto upgrade with a cron job"""
    with crontab.CronTab(user=True) as cron:
        for job in cron.find_comment("audius-cli auto-upgrade"):
            cron.remove(job)

        if not remove:
            log_file = ctx.obj["manifests_path"] / "auto-upgrade.log"
            job = cron.new(
                f"date >> {log_file}; /usr/local/bin/audius-cli upgrade >> {log_file} 2>&1",
                "audius-cli auto-upgrade",
            )

            job.setall(cron_expression)


if __name__ == "__main__":
    cli(obj={})
